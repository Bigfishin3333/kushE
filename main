#include <TFT_eSPI.h>
#include <SPI.h>
#include <Wire.h>
#include <Adafruit_MLX90614.h>
#include <ezButton.h>
#include <EEPROM.h>
#include <stdint.h>

// Configuration and Error Handling
// below

class DabAlarmConfig {
public:
    struct TemperatureSettings {
        constexpr static int DEFAULT_DAB_TEMP = 550;
        constexpr static int DEFAULT_DUNK_TEMP = 300;
        constexpr static int MIN_TEMP = 200;
        constexpr static int MAX_TEMP = 700;
        constexpr static int TEMP_STEP = 10;
    };

    struct HardwareSettings {
        constexpr static uint8_t BUZZER_PIN = 25;
        constexpr static uint8_t BUTTON_UP_PIN = 35;
        constexpr static uint8_t BUTTON_LOW_PIN = 0;
        constexpr static uint8_t ADC_PIN = 34;
    };

    struct DisplaySettings {
        constexpr static uint16_t SCREEN_WIDTH = 240;
        constexpr static uint16_t SCREEN_HEIGHT = 135;
    };

    struct InteractionSettings {
        constexpr static unsigned long LONG_PRESS_DURATION = 1000;
        constexpr static unsigned long MENU_TIMEOUT = 10000;
    };

    struct EEPROMAddresses {
        constexpr static int DAB_TEMP_ADDR = 0;
        constexpr static int DUNK_TEMP_ADDR = 4;
        constexpr static int MUTE_STATE_ADDR = 8;
    };
};

class ErrorHandler {
public:
    enum class ErrorType {
        SENSOR_INIT_FAILED,
        TEMPERATURE_READ_ERROR,
        DISPLAY_ERROR,
        EEPROM_ERROR
    };

    static void logError(ErrorType type, const String& message) {
        Serial.print("Error (");
        switch(type) {
            case ErrorType::SENSOR_INIT_FAILED: 
                Serial.print("Sensor Init"); 
                break;
            case ErrorType::TEMPERATURE_READ_ERROR: 
                Serial.print("Temp Read"); 
                break;
            case ErrorType::DISPLAY_ERROR: 
                Serial.print("Display"); 
                break;
            case ErrorType::EEPROM_ERROR: 
                Serial.print("EEPROM"); 
                break;
        }
        Serial.print("): ");
        Serial.println(message);
    }

    static void handleCriticalError(ErrorType type) {
        logError(type, "Critical error detected");
    }
};

// Font Definitions
#define FONT_SMALL &FreeSans9pt7b
#define FONT_MEDIUM &FreeSansBold12pt7b
#define FONT_LARGE &FreeSansBold18pt7b
#define FF17 &FreeSans9pt7b
const int ADC_PIN = 34;

long batteryPrevMillis = 0;
int batteryInterval = 400;
const int VREF = 1100;
int voltageToPercent(float v) {
    // 1S LiPo typical voltage-to-percent approximation
    if (v >= 4.20) return 100;
    else if (v >= 4.15) return 95;
    else if (v >= 4.11) return 90;
    else if (v >= 4.08) return 85;
    else if (v >= 4.02) return 80;
    else if (v >= 3.98) return 75;
    else if (v >= 3.95) return 70;
    else if (v >= 3.91) return 65;
    else if (v >= 3.87) return 60;
    else if (v >= 3.85) return 55;
    else if (v >= 3.84) return 50;
    else if (v >= 3.82) return 45;
    else if (v >= 3.80) return 40;
    else if (v >= 3.79) return 35;
    else if (v >= 3.77) return 30;
    else if (v >= 3.75) return 25;
    else if (v >= 3.73) return 20;
    else if (v >= 3.71) return 15;
    else if (v >= 3.69) return 10;
    else if (v >= 3.6)  return 5;
    else                return 0;
}

// Main DabAlarm Class
// below

class DabAlarm {
public:
    DabAlarm() : 
        tft(TFT_eSPI()), 
        mlx(Adafruit_MLX90614()), 
        buttonUp(DabAlarmConfig::HardwareSettings::BUTTON_UP_PIN), 
        buttonLow(DabAlarmConfig::HardwareSettings::BUTTON_LOW_PIN) {}

    void begin() {
    // Initialize serial for debugging
    Serial.begin(115200);
    
    // Initialize display first and keep it black
    tft.init();
    tft.setRotation(1);
    tft.fillScreen(TFT_BLACK);
    delay(300);
    // Set initial display settings to prevent random flashing
    tft.setTextColor(TFT_WHITE);
    tft.setTextSize(1);
    
    // Delay briefly to prevent initial screen flash
    delay(100);
    
    // Initialize other hardware components
    initializeHardware();
    
    // Load saved settings
    loadSavedSettings();
    
    // Clear screen completely before boot screen
    clearScreen();
    
    // Show boot screen
    
    
    // Clear screen again before main screen
    clearScreen();
    
    // Draw main screen
    drawMainScreen();
}
   void update() {
    // Update button states
    buttonUp.loop();
    buttonLow.loop();
    
    // Update temperature
    static unsigned long lastTempUpdate = 0;
    if (millis() - lastTempUpdate > 500) {
        updateTemperature();
        lastTempUpdate = millis();
    }
    
    static bool mainScreenInitialized = false;
    batteryfunction();
    
    // Handle menu and interaction
    handleMenuInteraction();
    
    // Non-blocking sound generation
    static unsigned long lastSoundUpdate = 0;
    if (millis() - lastSoundUpdate > 50) {  // Adjust timing as needed
        checkTemperatureAlarms();
        lastSoundUpdate = millis();
    }

    if (!mainScreenInitialized) {
        drawMainScreen();
        mainScreenInitialized = true;
        return;  // Exit after first initialization
    }
    
    // Update display if needed - only update specific parts instead of full redraw
    static int lastDisplayTemp = -1;
    static bool lastMuteState = false;
    
    if (currentMenu == MenuState::MAIN_SCREEN) {
        bool needsUpdate = false;
        
        // Check if temperature changed
        if (state.currentTemp != lastDisplayTemp) {
            updateTemperatureDisplay();
            updateTemperatureStatus();
            lastDisplayTemp = state.currentTemp;
            needsUpdate = true;
        }
        
        // Check if mute state changed
        if (state.isMuted != lastMuteState) {
            updateBottomBanner();
            lastMuteState = state.isMuted;
            needsUpdate = true;
        }
        
        // Only do full redraw if this is the first time showing main screen
        static bool mainScreenInitialized = false;
        if (!mainScreenInitialized) {
            drawMainScreen();
            mainScreenInitialized = true;
        }
    }
}

private:
   
    // Internal State and Components
    // below
    
    struct DeviceState {
        int currentTemp = 0;
        int previousTemp = 0;
        int dabTemp = DabAlarmConfig::TemperatureSettings::DEFAULT_DAB_TEMP;
        int dunkTemp = DabAlarmConfig::TemperatureSettings::DEFAULT_DUNK_TEMP;
        bool sensorConnected = false;
        bool isMuted = false;
    };
    bool dabBeepActive = false;
    bool dunkBeepActive = false; 
    int dabToneIndex = 0;
    unsigned long dabToneTimer = 0;
    bool dabTonePlaying = false;

    int dunkToneIndex = 0;
    unsigned long dunkToneTimer = 0;
    bool dunkTonePlaying = false;   
    enum class MenuState {
        MAIN_SCREEN,
        MENU_NAVIGATION,
        SET_DAB_TEMP,
        SET_DUNK_TEMP,
        TOGGLE_MUTE
    };

    // Hardware Components
    TFT_eSPI tft;
    Adafruit_MLX90614 mlx;
    ezButton buttonUp;
    ezButton buttonLow;

    // Internal State
    DeviceState state;
    MenuState currentMenu = MenuState::MAIN_SCREEN;
    int menuIndex = 0;
    unsigned long lastMenuAction = 0;
    unsigned long buttonPressTime = 0;  // Added missing variable declaration

    // Initialization Methods
    // below
    void initializeHardware() {
        // Initialize EEPROM
        EEPROM.begin(512);
        
        // Initialize sensor
        state.sensorConnected = mlx.begin();
        if (!state.sensorConnected) {
            ErrorHandler::handleCriticalError(
                ErrorHandler::ErrorType::SENSOR_INIT_FAILED
            );
        }
        
        // Initialize buttons
        buttonUp.setDebounceTime(50);
        buttonLow.setDebounceTime(50);
        
        // Initialize buzzer
        pinMode(DabAlarmConfig::HardwareSettings::BUZZER_PIN, OUTPUT);
    }
void batteryfunction() {
  if (millis() - batteryPrevMillis > batteryInterval) {
    int adc = analogRead(ADC_PIN);
    // For LilyGO T-Display (no voltage divider!)
    float batteryVoltage = ((float)adc / 4095.0) * 3.3;

    // Clamp to real-world range
    batteryVoltage = constrain(batteryVoltage, 3.2, 4.2);

    // Use your voltageToPercent() function
    int batteryPercent = voltageToPercent(batteryVoltage);

    // Choose battery color
    uint16_t batteryColor = TFT_GREEN;
    if (batteryPercent <= 20) batteryColor = TFT_RED;
    else if (batteryPercent <= 50) batteryColor = TFT_YELLOW;

    // Draw battery bar
    tft.fillRect(4, 116, 26, 14, TFT_BLACK); // Outline
    tft.fillRect(6, 118, 22, 10, TFT_DARKGREY); // Background
    float fillWidth = 22.0 * (batteryPercent / 100.0);
    tft.fillRect(6, 118, fillWidth, 10, batteryColor); // Fill

    // Optional: Flash if battery very low
    static bool flashState = false;
    static unsigned long lastFlashTime = 0;
    if (batteryPercent <= 10) {
      if (millis() - lastFlashTime > 400) {
        flashState = !flashState;
        lastFlashTime = millis();
      }
      if (flashState) {
        tft.fillRect(6, 118, 8, 10, TFT_RED);
      }
    }

    // Battery "tip"
    tft.fillRect(29, 120, 3, 6, TFT_BLACK);

    batteryPrevMillis = millis();
  }
}
    void loadSavedSettings() {
        // Load saved temperatures with validation
        state.dabTemp = loadTemperature(
            DabAlarmConfig::EEPROMAddresses::DAB_TEMP_ADDR, 
            DabAlarmConfig::TemperatureSettings::DEFAULT_DAB_TEMP
        );
        state.dunkTemp = loadTemperature(
            DabAlarmConfig::EEPROMAddresses::DUNK_TEMP_ADDR, 
            DabAlarmConfig::TemperatureSettings::DEFAULT_DUNK_TEMP
        );
        
        // Load mute state
        state.isMuted = loadMuteState();
    }


    // Display Methods
    // below

    void clearScreen() {
        tft.fillScreen(TFT_BLACK);
    }

    

   void drawMainScreen() {
    clearScreen();
    
    // Draw top banner
    tft.fillRect(0, 0, DabAlarmConfig::DisplaySettings::SCREEN_WIDTH, 25, TFT_BLUE);
    
    // Banner text - centered
    tft.setTextColor(TFT_WHITE);
    tft.setFreeFont(FONT_SMALL);
    
    String bannerText = "Kush Effect Dab Alarm";
    int16_t textWidth = tft.textWidth(bannerText);
    int16_t xPos = (DabAlarmConfig::DisplaySettings::SCREEN_WIDTH - textWidth) / 2;
    
    tft.setCursor(xPos, 18);
    tft.print(bannerText);
    
    // Draw bottom banner ALWAYS
    tft.fillRect(0, DabAlarmConfig::DisplaySettings::SCREEN_HEIGHT - 20, 
                 DabAlarmConfig::DisplaySettings::SCREEN_WIDTH, 20, TFT_DARKGREY);
    
    // Rest of the main screen drawing...
    // (temperature display, etc.)
    
    // Force a complete redraw of all screen elements
    tft.setFreeFont(FONT_LARGE);
    tft.setTextColor(TFT_WHITE);
    
    String tempString = "Temp: " + String(state.currentTemp) + "F";
    int16_t tempTextWidth = tft.textWidth(tempString);
    int16_t tempXPos = (DabAlarmConfig::DisplaySettings::SCREEN_WIDTH - tempTextWidth) / 2;
    
    tft.setCursor(tempXPos, 65);
    tft.print(tempString);
    
    // Target temperatures
    tft.setFreeFont(FONT_SMALL);
    tft.setCursor(30, 90);
    tft.print("Dab: ");
    tft.print(state.dabTemp);
    tft.print("F  Dunk: ");
    tft.print(state.dunkTemp);
    tft.print("F");
    
    // Status indicator
    drawTemperatureStatus();

    // Combine battery and mute status in bottom banner
    updateBottomBanner();
}


    void updateTemperatureDisplay() {
        // Clear only the temperature area
        tft.fillRect(0, 40, DabAlarmConfig::DisplaySettings::SCREEN_WIDTH, 35, TFT_BLACK);
        
        // Redraw temperature display
        tft.setFreeFont(FONT_LARGE);
        tft.setTextColor(TFT_WHITE);
        
        String tempString = "Temp: " + String(state.currentTemp) + "F";
        int16_t tempTextWidth = tft.textWidth(tempString);
        int16_t tempXPos = (DabAlarmConfig::DisplaySettings::SCREEN_WIDTH - tempTextWidth) / 2;
        
        tft.setCursor(tempXPos, 65);
        tft.print("Temp: ");
        tft.print(state.currentTemp);
        tft.print("F");
        
    }

    void updateTemperatureStatus() {
        // Clear only the status area
        tft.fillRect(10, 95, 220, 20, TFT_BLACK);
        
        tft.setFreeFont(FONT_SMALL);
        
        int dabDiff = abs(state.currentTemp - state.dabTemp);
        int dunkDiff = abs(state.currentTemp - state.dunkTemp);
        
        // Show text status
        tft.setCursor(15, 110);
        
        // Show exact ready states with tight tolerance
        if (dabDiff <= 5) {
            tft.setTextColor(TFT_GREEN);
            tft.print("DAB READY!");
        } else if (dunkDiff <= 5) {
            tft.setTextColor(TFT_YELLOW);
            tft.print("DUNK READY!");
        } else if (state.currentTemp > state.dabTemp + 15) {  // Show "TOO HOT" when 30+ degrees over
            tft.setTextColor(TFT_RED);
            tft.print("TOO HOT");
        }
    }

    void drawTemperatureStatus() {
        tft.setFreeFont(FONT_SMALL);
        
        // Clear previous status area completely
        tft.fillRect(10, 100, 220, 15, TFT_BLACK);
        
        int dabDiff = abs(state.currentTemp - state.dabTemp);
        int dunkDiff = abs(state.currentTemp - state.dunkTemp);
        
        tft.setCursor(15, 110);
        
        // Show status with better ranges
        if (dabDiff <= 5) {
            tft.setTextColor(TFT_GREEN);
            tft.print("DAB READY!");
        } else if (dunkDiff <= 5) {
            tft.setTextColor(TFT_YELLOW);
            tft.print("Dunk READY!");
        } else if (state.currentTemp > state.dabTemp + 30) {
            tft.setTextColor(TFT_RED);
            tft.print("TOO HOT");
        }
    }

   void updateBottomBanner() {
    // Draw bottom banner ALWAYS
    tft.fillRect(0, DabAlarmConfig::DisplaySettings::SCREEN_HEIGHT - 20, 
                 DabAlarmConfig::DisplaySettings::SCREEN_WIDTH, 20, TFT_DARKGREY);
    
    // Show battery status
   int adc = analogRead(ADC_PIN);
// (adjust the math below for your actual resistor divider ratio and VREF!)
float batteryVoltage = ((float)adc / 4095.0) * 2.0 * 3.3 * (VREF / 1000.0);
batteryVoltage = constrain(batteryVoltage, 3.2, 4.2); // Slightly wider range
int batteryPercent = voltageToPercent(batteryVoltage);

    // Draw battery indicator on left side
    tft.fillRect(4, 116, 26, 14, TFT_BLACK);
    tft.fillRect(6, 118, 22, 10, TFT_DARKGREY);
    
    // Color and fill based on battery percentage
    uint16_t batteryColor = TFT_GREEN;
if (batteryPercent < 20)
    batteryColor = TFT_RED;
else if (batteryPercent < 40)
    batteryColor = TFT_YELLOW;
    
    float fillWidth = 22.0 * (batteryPercent / 100.0);

    tft.fillRect(6, 118, fillWidth, 10, batteryColor);
    tft.fillRect(29, 120, 3, 6, TFT_BLACK);

    // Show mute status on right side
    if (state.isMuted) {
        tft.setTextColor(TFT_RED);
        tft.setFreeFont(FONT_SMALL);
        String muteText = "MUTED";
        int16_t muteWidth = tft.textWidth(muteText);
        int16_t muteXPos = DabAlarmConfig::DisplaySettings::SCREEN_WIDTH - muteWidth - 5;
        tft.setCursor(muteXPos, DabAlarmConfig::DisplaySettings::SCREEN_HEIGHT - 5);
        tft.print(muteText);
    }
}
    void drawMenuNavigation() {
        clearScreen();
        
        
        // Top banner with instructions
        tft.fillRect(0, 0, DabAlarmConfig::DisplaySettings::SCREEN_WIDTH, 25, TFT_BLUE);
        tft.setTextColor(TFT_WHITE);
        tft.setFreeFont(FONT_SMALL);
        
        String instructionText = "UP: Navigate  Down: Select";
        int16_t textWidth = tft.textWidth(instructionText);
        int16_t xPos = (DabAlarmConfig::DisplaySettings::SCREEN_WIDTH - textWidth) / 2;
        
        tft.setCursor(xPos, 18);
        tft.print(instructionText);
        
        // Menu items with proper sizing and spacing
        const char* menuItems[] = {"Set Dab Temp", "Set Alert Temp", "Toggle Mute"};
        
        for (int i = 0; i < 3; i++) {
            // Menu item background (highlight selected item)
            if (i == menuIndex) {
                tft.fillRect(10, 35 + (i * 30), 220, 25, TFT_DARKGREY);
            }
            
            // Menu item text - using consistent font
            tft.setTextColor(i == menuIndex ? TFT_GREEN : TFT_WHITE);
            tft.setFreeFont(FONT_MEDIUM);
            tft.setCursor(15, 52 + (i * 30));
            tft.print(menuItems[i]);
        }
    }

    void drawTempAdjustScreen(int temp, bool isDabTemp) {
        clearScreen();
        
        // Top banner with instructions
        tft.fillRect(0, 0, DabAlarmConfig::DisplaySettings::SCREEN_WIDTH, 25, TFT_BLUE);
        tft.setTextColor(TFT_WHITE);
        tft.setFreeFont(FONT_SMALL);
        
        String instructionText = "+/- 10: HOLD V: Exit";
        int16_t textWidth = tft.textWidth(instructionText);
        int16_t xPos = (DabAlarmConfig::DisplaySettings::SCREEN_WIDTH - textWidth) / 2;
        
        tft.setCursor(xPos, 18);
        tft.print(instructionText);
        
        // Content area with background
        tft.fillRect(10, 35, 220, 80, TFT_DARKGREY);
        
        // Title
        tft.setTextColor(TFT_WHITE);
        tft.setFreeFont(FONT_MEDIUM);
        
        String titleText = isDabTemp ? "Dab Temp" : "Alert Temp";
        int16_t titleWidth = tft.textWidth(titleText);
        int16_t titleXPos = (DabAlarmConfig::DisplaySettings::SCREEN_WIDTH - titleWidth) / 2;
        
        tft.setCursor(titleXPos, 55);
        tft.print(titleText);
        
        // Temperature value
        tft.setFreeFont(FONT_LARGE);
        tft.setTextColor(TFT_GREEN);
        String tempText = String(temp) + "F";
        int16_t tempWidth = tft.textWidth(tempText);
        int16_t tempXPos = (DabAlarmConfig::DisplaySettings::SCREEN_WIDTH - tempWidth) / 2;
        
        tft.setCursor(tempXPos, 90);
        tft.print(tempText);
    }

    void drawMuteToggleScreen() {
        clearScreen();
        
        // Top banner with instructions
        tft.fillRect(0, 0, DabAlarmConfig::DisplaySettings::SCREEN_WIDTH, 25, TFT_BLUE);
        tft.setTextColor(TFT_WHITE);
        tft.setFreeFont(FONT_SMALL);
        
        String instructionText = "UP/Down: Toggle  HOLD: Exit";
        int16_t textWidth = tft.textWidth(instructionText);
        int16_t xPos = (DabAlarmConfig::DisplaySettings::SCREEN_WIDTH - textWidth) / 2;
        
        tft.setCursor(xPos, 18);
        tft.print(instructionText);
        
        // Content area with background
        tft.fillRect(10, 35, 220, 80, TFT_BLACK);
        
        // Title
        tft.setTextColor(TFT_WHITE);
        tft.setFreeFont(FONT_MEDIUM);
        String titleText = "Sound Status";
        int16_t titleWidth = tft.textWidth(titleText);
        int16_t titleXPos = (DabAlarmConfig::DisplaySettings::SCREEN_WIDTH - titleWidth) / 2;
        
        tft.setCursor(titleXPos, 55);
        tft.print(titleText);
        
        // Mute status
        tft.setFreeFont(FONT_LARGE);
        tft.setTextColor(state.isMuted ? TFT_RED : TFT_GREEN);
        String statusText = state.isMuted ? "MUTED" : "UNMUTED";
        int16_t statusWidth = tft.textWidth(statusText);
        int16_t statusXPos = (DabAlarmConfig::DisplaySettings::SCREEN_WIDTH - statusWidth) / 2;
        
        tft.setCursor(statusXPos, 90);
        tft.print(statusText);
    }

    // Sound Effects (No Flashing)
    // below



// Also update your playDabBeep() function to be more reliable:
bool playDabBeep() {
    if (state.isMuted) {
        dabBeepActive = false;
        return false;
    }

    // Twilight up-glide: step from 900 Hz up to 1800 Hz in ~8 steps
    static const int twiNotes[] = {900, 1050, 1200, 1400, 1600, 1800, 1950, 2100};
    static const int twiDurations[] = {40, 40, 40, 40, 40, 40, 40, 80}; // ms
    static int currentTone = 0;
    static unsigned long lastToneTime = 0;
    static bool isPlaying = false;

    unsigned long now = millis();

    if (!isPlaying) {
        currentTone = 0;
        isPlaying = true;
        lastToneTime = now;
    }

    if (now - lastToneTime >= twiDurations[currentTone]) {
        noTone(DabAlarmConfig::HardwareSettings::BUZZER_PIN);
        currentTone++;
        lastToneTime = now;
        if (currentTone >= 8) {
            isPlaying = false;
            currentTone = 0;
            return false; // done
        }
    }

    if (isPlaying) {
        tone(DabAlarmConfig::HardwareSettings::BUZZER_PIN, twiNotes[currentTone]);
        // Stay here until duration is up
        return true;
    }

    return false;
}

// Similar fix for playDunkBeep():
bool playDunkBeep() {
    static unsigned long lastPlayedTime = 0;
    static int playCount = 0;
    static bool isPlaying = false;
    static bool isBeeping = false;            // Are we currently outputting a tone?
    static unsigned long phaseStartTime = 0;

    // Alarm settings
    const int alarmFreq = 1000;    // 1kHz
    const int alarmDur = 200;      // Beep duration (ms)
    const int pauseDur = 1000;     // Pause between beeps (ms)
    const int numBeeps = 3;

    if (state.isMuted) {
        dunkBeepActive = false;
        return false;
    }

    unsigned long now = millis();

    // Only allow once per "use" (30 sec cooldown)
    if (!isPlaying && (now - lastPlayedTime < 30000)) {
        dunkBeepActive = false;
        return false;
    }

    // Start new sequence if not playing
    if (!isPlaying) {
        playCount = 0;
        isPlaying = true;
        isBeeping = true;
        phaseStartTime = now;
        tone(DabAlarmConfig::HardwareSettings::BUZZER_PIN, alarmFreq);
        return true;
    }

    if (isPlaying) {
        if (isBeeping) {
            // Beeping phase
            if (now - phaseStartTime >= alarmDur) {
                noTone(DabAlarmConfig::HardwareSettings::BUZZER_PIN);
                isBeeping = false;
                phaseStartTime = now; // Start pause phase
            }
            return true;
        } else {
            // Pause phase
            if (now - phaseStartTime >= pauseDur) {
                playCount++;
                if (playCount >= numBeeps) {
                    isPlaying = false;
                    lastPlayedTime = now;
                    dunkBeepActive = false;
                    return false;
                } else {
                    // Start next beep
                    isBeeping = true;
                    phaseStartTime = now;
                    tone(DabAlarmConfig::HardwareSettings::BUZZER_PIN, alarmFreq);
                }
            }
            return true;
        }
    }

    return false;
}

 
    // Temperature and Menu Management  
    // below

    void updateTemperature() {
        if (!state.sensorConnected) return;
        
        state.previousTemp = state.currentTemp;
        state.currentTemp = mlx.readObjectTempF();
        
        // Basic error checking
        if (state.currentTemp < -40 || state.currentTemp > 1000) {
            ErrorHandler::logError(
                ErrorHandler::ErrorType::TEMPERATURE_READ_ERROR, 
                "Invalid temperature reading"
            );
            state.currentTemp = state.previousTemp;
        }
    }

   void checkTemperatureAlarms() {
    static int lastDabTriggerTemp = -1;
    static int lastDunkTriggerTemp = -1;
    static unsigned long lastAlarmCheck = 0;

    // Only check every 500ms to avoid rapid triggering
    if (millis() - lastAlarmCheck < 500) return;
    lastAlarmCheck = millis();

    // Detect cooling (falling temp)
    bool isCoolingDown = (state.previousTemp > state.currentTemp);

    int dabDiff = abs(state.currentTemp - state.dabTemp);
    int dunkDiff = abs(state.currentTemp - state.dunkTemp);

    // Dab alarm logic (only trigger on cooling down)
    if (isCoolingDown && dabDiff <= 5) {
        if (!dabBeepActive && lastDabTriggerTemp != state.dabTemp) {
            Serial.println("DAB ALARM TRIGGERED!");
            dabBeepActive = true;
            lastDabTriggerTemp = state.dabTemp;
        }
    } else if (dabDiff > 15) {
        lastDabTriggerTemp = -1;
    }

    // Dunk alarm logic (only trigger on cooling down)
    if (isCoolingDown && dunkDiff <= 5) {
        if (!dunkBeepActive && lastDunkTriggerTemp != state.dunkTemp) {
            Serial.println("DUNK ALARM TRIGGERED!");
            dunkBeepActive = true;
            lastDunkTriggerTemp = state.dunkTemp;
        }
    } else if (dunkDiff > 15) {
        lastDunkTriggerTemp = -1;
    }

    // Play audio sequences (non-blocking)
    if (dabBeepActive) {
        dabBeepActive = playDabBeep();
    }

    if (dunkBeepActive) {
        dunkBeepActive = playDunkBeep();
    }
}


    // Menu Interaction Methods
    // below

    void handleMenuInteraction() {
        switch (currentMenu) {
            case MenuState::MAIN_SCREEN:
                handleMainScreenInteraction();
                break;
            case MenuState::MENU_NAVIGATION:
                handleMenuNavigationInteraction();
                break;
            case MenuState::SET_DAB_TEMP:
                handleDabTempAdjustment();
                break;
            case MenuState::SET_DUNK_TEMP:
                handleDunkTempAdjustment();
                break;
            case MenuState::TOGGLE_MUTE:
                handleMuteToggle();
                break;
        }
        
        // Menu timeout
        if (currentMenu != MenuState::MAIN_SCREEN && 
            (millis() - lastMenuAction > DabAlarmConfig::InteractionSettings::MENU_TIMEOUT)) {
            currentMenu = MenuState::MAIN_SCREEN;
            drawMainScreen();
        }
    }

    void handleMainScreenInteraction() {
        // Handle UP button
        if (buttonUp.isPressed()) {
            buttonPressTime = millis();
            lastMenuAction = millis();
        }
        
        if (buttonUp.isReleased()) {
            unsigned long pressDuration = millis() - buttonPressTime;
            if (pressDuration > DabAlarmConfig::InteractionSettings::LONG_PRESS_DURATION) {
                // Long press - enter menu
                currentMenu = MenuState::MENU_NAVIGATION;
                menuIndex = 0;
                drawMenuNavigation();
            } 
        }
        
        
       
    }

    void handleMenuNavigationInteraction() {
    // Navigate menu items
    if (buttonUp.isPressed()) {
        menuIndex = (menuIndex + 1) % 3;
        drawMenuNavigation();
        lastMenuAction = millis();
    }
    
    // Select menu item
    if (buttonLow.isPressed()) {
        buttonPressTime = millis();
        lastMenuAction = millis();
    }
    
    if (buttonLow.isReleased()) {
        unsigned long pressDuration = millis() - buttonPressTime;
        
        if (pressDuration > DabAlarmConfig::InteractionSettings::LONG_PRESS_DURATION) {
            // Long press DOWN - return to main screen
            currentMenu = MenuState::MAIN_SCREEN;
            drawMainScreen();
        } else {
            // Short press - select menu item
            switch (menuIndex) {
                case 0:
                    currentMenu = MenuState::SET_DAB_TEMP;
                    drawTempAdjustScreen(state.dabTemp, true);
                    break;
                case 1:
                    currentMenu = MenuState::SET_DUNK_TEMP;
                    drawTempAdjustScreen(state.dunkTemp, false);
                    break;
                case 2:
                    currentMenu = MenuState::TOGGLE_MUTE;
                    drawMuteToggleScreen();
                    break;
            }
        }
    }
}

void handleDabTempAdjustment() {
    static bool settingChanged = false;
    static unsigned long lastChangeTime = 0;

    unsigned long currentTime = millis();

    // Add a minimum interval between changes
    if (currentTime - lastChangeTime < 200) {
        return;  // Prevent rapid successive changes
    }


    if (buttonUp.isPressed()) {
        state.dabTemp = min(
            state.dabTemp + DabAlarmConfig::TemperatureSettings::TEMP_STEP, 
            DabAlarmConfig::TemperatureSettings::MAX_TEMP
        );
        saveTemperature(
            DabAlarmConfig::EEPROMAddresses::DAB_TEMP_ADDR, 
            state.dabTemp
        );
        drawTempAdjustScreen(state.dabTemp, false);
        lastMenuAction = millis();
        
    }
    
    if (buttonLow.isPressed()) {
        buttonPressTime = millis();
    }
    
    if (buttonLow.isReleased()) {
        unsigned long pressDuration = millis() - buttonPressTime;
        
        if (pressDuration > DabAlarmConfig::InteractionSettings::LONG_PRESS_DURATION) {
            // Long press to exit
            currentMenu = MenuState::MAIN_SCREEN;
            drawMainScreen();
        } else if (!settingChanged) {
            // Short press to decrease only if no previous setting change
            state.dabTemp = max(
                state.dabTemp - DabAlarmConfig::TemperatureSettings::TEMP_STEP, 
                DabAlarmConfig::TemperatureSettings::MIN_TEMP
            );
            saveTemperature(
                DabAlarmConfig::EEPROMAddresses::DAB_TEMP_ADDR, 
                state.dabTemp
            );
            drawTempAdjustScreen(state.dabTemp, false);
            lastMenuAction = millis();
        }
        
        // Reset the change flag
        settingChanged = false;
    }
}
void handleDunkTempAdjustment() {
    static bool settingChanged = false;
    

    if (buttonUp.isPressed()) {
        state.dunkTemp = min(
            state.dunkTemp + DabAlarmConfig::TemperatureSettings::TEMP_STEP, 
            DabAlarmConfig::TemperatureSettings::MAX_TEMP
        );
        saveTemperature(
            DabAlarmConfig::EEPROMAddresses::DUNK_TEMP_ADDR, 
            state.dunkTemp
        );
        drawTempAdjustScreen(state.dunkTemp, false);
        lastMenuAction = millis();
        settingChanged = false;
    }
    
    if (buttonLow.isPressed()) {
        buttonPressTime = millis();
    }
    
    if (buttonLow.isReleased()) {
        unsigned long pressDuration = millis() - buttonPressTime;
        
        if (pressDuration > DabAlarmConfig::InteractionSettings::LONG_PRESS_DURATION) {
            // Long press to exit
            currentMenu = MenuState::MAIN_SCREEN;
            drawMainScreen();
        } else if (!settingChanged) {
            // Short press to decrease only if no previous setting change
            state.dunkTemp = max(
                state.dunkTemp - DabAlarmConfig::TemperatureSettings::TEMP_STEP, 
                DabAlarmConfig::TemperatureSettings::MIN_TEMP
            );
            saveTemperature(
                DabAlarmConfig::EEPROMAddresses::DUNK_TEMP_ADDR, 
                state.dunkTemp
            );
            drawTempAdjustScreen(state.dunkTemp, false);
            lastMenuAction = millis();
        }
        
        // Reset the change flag
        settingChanged = false;
    }
}

void handleMuteToggle() {
    static bool settingChanged = false;

    if (buttonUp.isPressed()) {
        state.isMuted = !state.isMuted;
        saveMuteState(state.isMuted);
        drawMuteToggleScreen();
        lastMenuAction = millis();
        settingChanged = false;
    }
    
    if (buttonLow.isPressed()) {
        buttonPressTime = millis();
    }
    
    if (buttonLow.isReleased()) {
        unsigned long pressDuration = millis() - buttonPressTime;
        
        if (pressDuration > DabAlarmConfig::InteractionSettings::LONG_PRESS_DURATION) {
            // Long press to exit
            currentMenu = MenuState::MAIN_SCREEN;
            drawMainScreen();
        } else if (!settingChanged) {
            // Short press only if no previous setting change
            state.isMuted = !state.isMuted;
            saveMuteState(state.isMuted);
            drawMuteToggleScreen();
            lastMenuAction = millis();
        }
        
        // Reset the change flag
        settingChanged = false;
    }
}

   
    // EEPROM Helper Functions
    // below

    void saveTemperature(int address, int temp) {
        try {
            EEPROM.put(address, temp);
            EEPROM.commit();
        } catch (...) {
            ErrorHandler::handleCriticalError(
                ErrorHandler::ErrorType::EEPROM_ERROR
            );
        }
    }

    int loadTemperature(int address, int defaultTemp) {
        int temp;
        
        try {
            EEPROM.get(address, temp);
            
            // Validate loaded temperature
            if (temp < DabAlarmConfig::TemperatureSettings::MIN_TEMP || 
                temp > DabAlarmConfig::TemperatureSettings::MAX_TEMP) {
                temp = defaultTemp;
                saveTemperature(address, temp);
            }
            
            return temp;
        } catch (...) {
            ErrorHandler::handleCriticalError(
                ErrorHandler::ErrorType::EEPROM_ERROR
            );
            return defaultTemp;
        }
    }

   void saveMuteState(bool muteState) {
    try {
        // Update the internal state first
        state.isMuted = muteState;
        
        // Save to EEPROM
        EEPROM.put(DabAlarmConfig::EEPROMAddresses::MUTE_STATE_ADDR, muteState);
        EEPROM.commit();
        
        Serial.print("Saved mute state to EEPROM: ");
        Serial.println(muteState ? "MUTED" : "UNMUTED");
        
        // Force redraw of main screen to reflect mute state
        if (currentMenu == MenuState::MAIN_SCREEN) {
            drawMainScreen();
        }
    } catch (...) {
        ErrorHandler::handleCriticalError(
            ErrorHandler::ErrorType::EEPROM_ERROR
        );
    }
}

    bool loadMuteState() {
        bool muteState = false;  // Default to unmuted
        
        try {
            EEPROM.get(DabAlarmConfig::EEPROMAddresses::MUTE_STATE_ADDR, muteState);
            Serial.print("Loaded mute state from EEPROM: ");
            Serial.println(muteState ? "MUTED" : "UNMUTED");
            return muteState;
        } catch (...) {
            ErrorHandler::handleCriticalError(
                ErrorHandler::ErrorType::EEPROM_ERROR
            );
            Serial.println("EEPROM error, defaulting to UNMUTED");
            return false;  // Default to unmuted on error
        }
    }
};


// Global Instance and Main Functions
// below

DabAlarm dabAlarm;

void setup() {
    dabAlarm.begin();
}

void loop() {
    dabAlarm.update();
     
}
